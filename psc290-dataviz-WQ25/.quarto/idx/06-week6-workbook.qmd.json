{"title":"Week 6 (Workbook) - Visualizing Uncertainty","markdown":{"yaml":{"title":"Week 6 (Workbook) - Visualizing Uncertainty","author":"Emorie D Beck","format":{"html":{"code-tools":true,"code-copy":true,"code-line-numbers":true,"code-link":true,"theme":"united","highlight-style":"tango","df-print":"paged","code-fold":"show","toc":true,"toc-float":true,"self-contained":true,"footer":"PSC 290 - Data Visualization","logo":"https://github.com/emoriebeck/psc290-data-viz-2022/raw/main/01-week1-intro/02-code/02-images/ucdavis_logo_blue.png"}},"editor_options":{"chunk_output_type":"console"}},"headingText":"| code-line-numbers: \"6,10,11,12,13,14\"","containsRefs":false,"markdown":"\n\n```{r, echo = F}\nknitr::opts_chunk$set(echo = TRUE, warning = F, message = F, error = F, out.width = \"90%\")\noptions(knitr.kable.NA = '')\n```\n\n```{r, echo = T}\nlibrary(RColorBrewer)\nlibrary(knitr)\nlibrary(kableExtra)\nlibrary(plyr)\nlibrary(broom)\nlibrary(modelr)\nlibrary(lme4)\nlibrary(broom.mixed)\nlibrary(tidyverse)\nlibrary(ungeviz)\nlibrary(ggdist)\nlibrary(tidybayes)\nlibrary(distributional)\nlibrary(gganimate)\n```\n\n# Visualizing Uncertainty\n\n## Visualizing Uncertainty\n\n-   Why is visualizing uncertainty important?\n    -   Point estimates are over-emphasized and interval estimates are unemphasized (or ignored)\n    -   Most people <font color=\"red\">*misperceive*</font> both (1) common uncertainty visualizations and (2) most common uncertainty metrics\n    -   In other words, people make errors about error\n    -   Probability is hard, and most aren't taught about probability distributions (and more)\n\n## Theories of Visualizing Uncertainty\n\nWhy do people misperceive uncertainty, and how can we mitigate it?\n\n::: fragment\n```{r, echo = F, fig.align='center', out.width=\"70%\"}\nknitr::include_graphics(\"https://github.com/emoriebeck/psc290-data-viz-2022/raw/main/06-week6-uncertainty/02-images/uncert-theories.png\")\n```\n:::\n\n## Quick Side Note: Custom Themes\n\n-   We have a lot to cover today, so I'm going to skip over some of the usual \"how to start with the basics and make it aesthetically pleasing\"\n-   Instead, we'll create a custom these that captures some of our usual additions\\\n-   This will save us both time and text!\\\n-   I highly recommend doing this in your own work\n\n```{r}\nmy_theme <- function(){\n  theme_classic() + \n  theme(\n    legend.position = \"bottom\"\n    , legend.title = element_text(face = \"bold\", size = rel(1))\n    , legend.text = element_text(face = \"italic\", size = rel(1))\n    , axis.text = element_text(face = \"bold\", size = rel(1.1), color = \"black\")\n    , axis.title = element_text(face = \"bold\", size = rel(1.2))\n    , plot.title = element_text(face = \"bold\", size = rel(1.2), hjust = .5)\n    , plot.subtitle = element_text(face = \"italic\", size = rel(1.2), hjust = .5)\n    , strip.text = element_text(face = \"bold\", size = rel(1.1), color = \"white\")\n    , strip.background = element_rect(fill = \"black\")\n    )\n}\n```\n\n## Error Bars\n\n-   First, let's examine the usual ways that we show uncertainty around point estimates (e.g., means, model parameter estimates, etc.) using interval estimates (+/- 1 SE/D, confidence interval)\n\n```{r, echo=F}\nload(url(\"https://github.com/emoriebeck/psc290-data-viz-2022/blob/main/05-week5-time-series/01-data/gsoep.RData?raw=true\"))\ngsoep <- gsoep %>% mutate(gender = haven::zap_labels(gender))\ngsoep\n```\n\n```{r}\npomp <- function(x) (x - min(x, na.rm = T))/(max(x, na.rm = T) - min(x, na.rm = T))*10\ngsoep %>%\n  filter(year == 2005) %>%\n  filter(SID %in% sample(unique(.$SID, 500))) %>%\n  mutate(SRhealth = pomp(SRhealth)) %>%\n  group_by(SID, age) %>%\n  mutate(health = rowMeans(cbind(SRhealth, satHealth))) %>%\n  ungroup() %>%\n  select(SID, age, health) %>%\n  drop_na()\n```\n\n```{r}\ngsoep_desc <- gsoep %>%\n  filter(year == 2005 & age < 30) %>%\n  filter(SID %in% sample(unique(.$SID), 500)) %>%\n  mutate(SRhealth = pomp(SRhealth)) %>%\n  group_by(SID, age) %>%\n  mutate(health = rowMeans(cbind(SRhealth, satHealth), na.rm = T)) %>%\n  ungroup() %>%\n  select(SID, age, health) %>%\n  drop_na() %>%\n  mutate(\n    mean = mean(health)\n    , sd = sd(health)\n    , se = sd/sqrt(n())\n    , ci99 = se*2.576\n    , ci95 = se*1.96\n    , ci80 = se*1.282\n    )\ngsoep_desc\n```\n\n```{r}\ngsoep_desc <- gsoep_desc %>% \n  select(mean:ci80, health, SID) %>%\n  pivot_longer(\n    cols = c(-mean, -SID)\n    , names_to = \"measure\"\n    , values_to = \"value\"\n    ) %>%\n  mutate(SID = ifelse(measure == \"health\" | row_number() %in% 1:5, SID, NA)) %>%\n  drop_na() %>%\n  mutate(measure = factor(measure, rev(c(\"health\", \"sd\", \"se\", \"ci99\", \"ci95\", \"ci80\"))))\ngsoep_desc\n```\n\n```{r, fig.dim=c(10,3)}\ngsoep_desc %>%\n  ggplot(aes(y = measure, x = mean)) +\n    geom_point(size = 3, color = \"darkorange3\") + \n    geom_jitter(\n      data = gsoep_desc %>% filter(measure == \"health\")\n      , aes(x = value), alpha = .5, height = .3, width = 0\n    ) + \n    geom_errorbar(\n      data =  gsoep_desc %>% filter(measure != \"health\")\n      , aes(xmin = mean - value, xmax = mean + value)\n      , width = .1\n      ) + \n    geom_point(size = 3, color = \"darkorange3\") + \n    my_theme()\n```\n\n## So What Do We Do?\n\n-   Lots of things, not all of which we have time for today. See also:\n    -   <https://janhove.github.io/visualise_uncertainty/>\n    -   <https://wilkelab.org/SDS375/slides/visualizing-uncertainty.html#1>\n    -   <https://wilkelab.org/ungeviz/>\n    -   #TeamBayes: <http://mjskay.github.io/tidybayes/>\n    -   #TeamFrequentist: <https://mjskay.github.io/ggdist/>\n\n## Outline for Today:\n\n-   Proportions / Probability\n    -   icon array\n-   Point Estimates\n    -   half-eye\n    -   gradient interval\n    -   quantile dotplot\n    -   raincloud\n-   Animated (sometimes)\n    -   hypothetical outcome plots\n    -   ensemble display\n\n# Proportions / Probability\n\n-   We already covered proportions and probability, but this one deserves being highlighted itself\n-   How much of our sample was unmarried?\n\n```{r}\ngsoep %>%\n  filter(year == 2012 & !is.na(marital)) %>%\n  mutate(marital = ifelse(marital == 4, \"Never Married\", \"Married\")) %>%\n  group_by(marital) %>%\n  tally() %>%\n  ungroup() %>%\n  mutate(prop = round(n/sum(n)*100))\n```\n\n-   We have to trick `ggplot2` into making this figure with a grid\n\n```{r}\ntibble(\n  value = c(rep(1, 76), rep(2,24))\n  , x = rep(1:10, each = 10)\n  , y = rep(1:10, times = 10)\n  ) \n```\n\n```{r}\n#| code-line-numbers: \"6-9\"\ntibble(\n  value = c(rep(1, 76), rep(2,24))\n  , y = rep(1:10, each = 10)\n  , x = rep(1:10, times = 10)\n  ) %>%\n  ggplot(aes(x = x, y = y, color = factor(value))) +\n    geom_point(shape = \"square\", size = 5) + \n    theme_void() + \n    theme(legend.position = \"none\")\n```\n\nLet's clean it up:\n\n```{r fig.dim=c(4,4.2)}\n#| code-line-numbers: \"7-9,12\"\ntibble(\n  value = c(rep(1, 76), rep(2,24))\n  , y = rep(1:10, each = 10)\n  , x = rep(1:10, times = 10)\n  ) %>%\n  ggplot(aes(x = x, y = y, color = factor(value))) +\n    geom_point(shape = \"square\", size = 8) + \n    scale_color_manual(values = c(\"lightgrey\", \"darkblue\")) + \n    labs(title = \"24% Remained Unmarried in 2012\") + \n    theme_void() + \n    theme(legend.position = \"none\"\n          , plot.title = element_text(hjust = .5, face = \"bold\"))\n```\n\n# Point Estimates\n\n-   Most often, we want to visualize either point esimates or other visualizations of models\n-   We touched on this a couple of weeks ago when we talked about `broom` and `broom.mixed`\n-   I mentioned then that one of the challenges comes from where the interval estimate comes from, which includes:\n    -   (Frequentist) Standard Errors\n    -   (Frequentist) Confidence Intervals\n    -   Bootstrapped / Profile Confidence Intervals\n    -   Prediction Intervals\n    -   (Bayesian) Credible Intervals\n    -   (Bayesian) Posterior Distributions\n-   I'll stay out of Bayes for now :(\n\n```{r}\ngsoep_ex <- gsoep %>%\n  filter(year == \"2000\") %>%\n  select(SID, age, marital, gender) %>%\n  inner_join(\n    gsoep %>%\n      filter(year == \"2015\") %>%\n      select(SID, SRhealth)\n  ) %>%\n  mutate(marital = factor(\n    marital\n    , 1:4\n    , c(\"Married\", \"Separated\", \"Widowed\", \"Never Married\")\n    ), age = age/10\n    , gender = factor(gender, c(1,2), c(\"Male\", \"Female\"))) %>%\n  drop_na()\ngsoep_ex\n```\n\n## Point Estimates From Model Predictions\n\n```{r, echo = F, fig.dim=c(12, 6), fig.align='center'}\nm1 <- lm(SRhealth ~ marital + age, data = gsoep_ex)\ntidy1 <- tidy(m1)\n\np1 <- tidy1 %>%\n  filter(term != \"(Intercept)\") %>%\n  ggplot(aes(y = term)) + \n    stat_halfeye(\n        aes(xdist = dist_student_t(df = df.residual(m1), mu = estimate, sigma = std.error)), \n        scale = .5\n    ) +\n  labs(\n    x = \"Parameter Estimates\"\n    , y = NULL\n    , title = \"stat_halfeye()\"\n    ) + \n  my_theme()\n\np2 <-tidy1 %>%\n  filter(term != \"(Intercept)\") %>%\n  ggplot(aes(y = term)) + \n    stat_gradientinterval(\n      aes(xdist = dist_student_t(df = df.residual(m1), mu = estimate, sigma = std.error))\n      , scale = .75\n    ) + \n  labs(\n    x = \"Parameter Estimates\"\n    , y = NULL\n    , title = \"stat_gradientinterval()\"\n    ) + \n  my_theme()\n\np3 <-tidy1 %>%\n  filter(term != \"(Intercept)\") %>%\n  ggplot(aes(y = term)) + \n    stat_dotsinterval(\n      aes(xdist = dist_student_t(df = df.residual(m1), mu = estimate, sigma = std.error))\n      , quantiles = 50\n    ) + \n  labs(\n    x = \"Parameter Estimates\"\n    , y = NULL\n    , title = \"stat_dotsinterval()\"\n    ) + \n  my_theme()\n\np4 <-tidy1 %>%\n  filter(term != \"(Intercept)\") %>%\n  ggplot(aes(y = term)) + \n    stat_dots(\n      aes(xdist = dist_student_t(df = df.residual(m1), mu = estimate, sigma = std.error))\n      , quantiles = 50\n    ) + \n  labs(\n    x = \"Parameter Estimates()\"\n    , y = NULL\n    , title = \"stat_dots()\"\n    ) + \n  my_theme()\n\np5 <-tidy1 %>%\n  filter(term != \"(Intercept)\") %>%\n  ggplot(aes(y = term)) + \n    stat_dots(\n      aes(xdist = dist_student_t(df = df.residual(m1), mu = estimate, sigma = std.error))\n      , side = \"bottomleft\", layout = \"swarm\"\n    ) + \n    stat_histinterval(\n      aes(xdist = dist_student_t(df = df.residual(m1), mu = estimate, sigma = std.error))\n    ) + \n  labs(\n    x = \"Parameter Estimates\"\n    , y = NULL\n    , title = \"stat_halfeye() + stat_dots()\"\n    ) + \n  my_theme()\n\np6 <-tidy1 %>%\n  filter(term != \"(Intercept)\") %>%\n  ggplot(aes(y = term)) + \n    stat_eye(\n      aes(xdist = dist_student_t(df = df.residual(m1), mu = estimate, sigma = std.error))\n    ) + \n  labs(\n    x = \"Parameter Estimates\"\n    , y = NULL\n    , title = \"stat_eye()\"\n    ) + \n  my_theme()\n\ncowplot::plot_grid(p1, p2, p3, p6, p5, p4, nrow = 2)\n```\n\n## Marginal Means from Model Predictions\n\n```{r, echo = F, fig.dim=c(12, 6), fig.align='center'}\nm1 <- lm(SRhealth ~ marital + age, data = gsoep_ex)\ntidy1 <- tidy(m1)\n\np1 <- gsoep_ex %>%\n  data_grid(marital) %>%\n  mutate(age = mean(gsoep_ex$age)) %>%\n  augment(m1, newdata = ., se_fit = T) %>%\n  ggplot(aes(y = marital)) + \n    stat_halfeye(\n        aes(xdist = dist_student_t(df = df.residual(m1), mu = .fitted, sigma = .se.fit)), \n        scale = .5\n    ) +\n  labs(\n    x = \"Parameter Estimates\"\n    , y = NULL\n    , title = \"stat_halfeye()\"\n    ) + \n  my_theme()\n\np2 <- gsoep_ex %>%\n  data_grid(marital) %>%\n  mutate(age = mean(gsoep_ex$age)) %>%\n  augment(m1, newdata = ., se_fit = T) %>%\n  ggplot(aes(y = marital)) + \n    stat_gradientinterval(\n      aes(xdist = dist_student_t(df = df.residual(m1), mu = .fitted, sigma = .se.fit))\n      , scale = .75\n    ) + \n  labs(\n    x = \"Parameter Estimates\"\n    , y = NULL\n    , title = \"stat_gradientinterval()\"\n    ) + \n  my_theme()\n\np3 <- gsoep_ex %>%\n  data_grid(marital) %>%\n  mutate(age = mean(gsoep_ex$age)) %>%\n  augment(m1, newdata = ., se_fit = T) %>%\n  ggplot(aes(y = marital)) + \n    stat_dotsinterval(\n      aes(xdist = dist_student_t(df = df.residual(m1), mu = .fitted, sigma = .se.fit))\n      , quantiles = 50\n    ) + \n  labs(\n    x = \"Parameter Estimates\"\n    , y = NULL\n    , title = \"stat_dotsinterval()\"\n    ) + \n  my_theme()\n\np4 <- gsoep_ex %>%\n  data_grid(marital) %>%\n  mutate(age = mean(gsoep_ex$age)) %>%\n  augment(m1, newdata = ., se_fit = T) %>%\n  ggplot(aes(y = marital)) + \n    stat_dots(\n      aes(xdist = dist_student_t(df = df.residual(m1), mu = .fitted, sigma = .se.fit))\n      , quantiles = 50\n    ) + \n  labs(\n    x = \"Parameter Estimates()\"\n    , y = NULL\n    , title = \"stat_dots()\"\n    ) + \n  my_theme()\n\np5 <- gsoep_ex %>%\n  data_grid(marital) %>%\n  mutate(age = mean(gsoep_ex$age)) %>%\n  augment(m1, newdata = ., se_fit = T) %>%\n  ggplot(aes(y = marital)) + \n    stat_dots(\n      aes(xdist = dist_student_t(df = df.residual(m1), mu = .fitted, sigma = .se.fit))\n      , side = \"bottomleft\", layout = \"swarm\"\n    ) + \n    stat_histinterval(\n      aes(xdist = dist_student_t(df = df.residual(m1), mu = .fitted, sigma = .se.fit))\n    ) + \n  labs(\n    x = \"Parameter Estimates\"\n    , y = NULL\n    , title = \"stat_halfeye() + stat_dots()\"\n    ) + \n  my_theme()\n\np6 <- gsoep_ex %>%\n  data_grid(marital) %>%\n  mutate(age = mean(gsoep_ex$age)) %>%\n  augment(m1, newdata = ., se_fit = T) %>%\n  ggplot(aes(y = marital)) + \n    stat_eye(\n      aes(xdist = dist_student_t(df = df.residual(m1), mu = .fitted, sigma = .se.fit))\n    ) + \n  labs(\n    x = \"Parameter Estimates\"\n    , y = NULL\n    , title = \"stat_eye()\"\n    ) + \n  my_theme()\n\ncowplot::plot_grid(p1, p2, p3, p6, p5, p4, nrow = 2)\n```\n\n## Point Estimates and Marginal Means\n\n-   `stat_halfeye()`: Visual Boundaries\n-   `stat_eye()`: Visual Boundaries\n-   `stat_gradientinterval()`: Visual Semiotics\n-   `stat_dots()`: Frequency Framing\n-   `stat_dotsinterval()`: Frequency Framing\n-   `stat_halfeye()`+ `stat_dots()`: Visual Boundaries + Frequency Framing\n\n### Core syntax\n\n-   The benefit of ggdist is that it allows you to use essentially identical syntax to produce lots of different kinds of plots\\\n-   All we have to do is swap out the `geom`\n\n```{r}\nm1 <- lm(SRhealth ~ marital + age, data = gsoep_ex)\ntidy1 <- tidy(m1)\n\ntidy1 %>%\n  filter(term != \"(Intercept)\") %>%\n  ggplot(aes(y = term)) + \n    stat_halfeye(\n        aes(xdist = dist_student_t(df = df.residual(m1), mu = estimate, sigma = std.error))\n    ) +\n  my_theme()\n```\n\n### `stat_halfeye()`\n\nWe can pull the predictions from model terms or marginal means\n\nModel Terms:\n\n```{r}\n#| code-line-numbers: \"4\"\ntidy1 %>%\n  filter(term != \"(Intercept)\") %>%\n  ggplot(aes(y = term)) + \n    stat_halfeye(\n        aes(xdist = dist_student_t(df = df.residual(m1), mu = estimate, sigma = std.error))\n    ) +\n  my_theme()\n```\n\nMarginal Means:\n\n```{r}\n#| code-line-numbers: \"6-8\"\ngsoep_ex %>%\n  data_grid(marital) %>%\n  mutate(age = mean(gsoep_ex$age)) %>%\n  augment(m1, newdata = ., se_fit = T) %>%\n  ggplot(aes(y = marital)) + \n    stat_halfeye(\n        aes(xdist = dist_student_t(df = df.residual(m1), mu = .fitted, sigma = .se.fit)), \n    ) +\n  my_theme()\n```\n\nLet's do a little hack and create our whole plots **except** the `geom`, so that we can build them with less syntax:\n\n```{r}\np1 <- tidy1 %>%\n  filter(term != \"(Intercept)\") %>%\n  ggplot(aes(y = term)) + \n  labs(\n    x = \"Parameter Estimate\"\n    , y = NULL\n    , title = \"Model Estimates\"\n    , caption = \"Outcome: Self-Rated Health\"\n    ) +\n  my_theme()\n```\n\n```{r}\np2 <- gsoep_ex %>%\n  data_grid(marital) %>%\n  mutate(age = mean(gsoep_ex$age)) %>%\n  augment(m1, newdata = ., se_fit = T) %>%\n  ggplot(aes(y = marital)) + \n  labs(\n    x = \"Model Predicted Self-Rated Health\"\n    , title = \"Marginal Means\"\n    , y = NULL\n    ) +\n  my_theme()\n```\n\nWe can pull the predictions from model terms or marginal means\n\nModel Terms:\n\n```{r}\np1 +\n  stat_halfeye(\n      aes(xdist = dist_student_t(df = df.residual(m1), mu = estimate, sigma = std.error))\n  ) + \n  labs(subtitle = \"stat_halfeye()\")\n```\n\nMarginal Means:\n\n```{r}\np2 + \n  stat_halfeye(\n      aes(xdist = dist_student_t(df = df.residual(m1), mu = .fitted, sigma = .se.fit)), \n  ) + \n  labs(subtitle = \"stat_halfeye()\")\n```\n\n### `stat_eye()`\n\nModel Terms:\n\n```{r}\np1 +\n  stat_eye(\n      aes(xdist = dist_student_t(df = df.residual(m1), mu = estimate, sigma = std.error))\n  ) + \n  labs(subtitle = \"stat_eye()\")\n```\n\nMarginal Means:\n\n```{r}\np2 + \n  stat_eye(\n      aes(xdist = dist_student_t(df = df.residual(m1), mu = .fitted, sigma = .se.fit)), \n  ) + \n  labs(subtitle = \"stat_eye()\")\n```\n\n### `stat_gradientinterval()`\n\nModel Terms:\n\n```{r}\np1 +\n  stat_gradientinterval(\n      aes(xdist = dist_student_t(df = df.residual(m1), mu = estimate, sigma = std.error))\n  ) + \n  labs(subtitle = \"stat_gradientinterval()\")\n```\n\nMarginal Means:\n\n```{r}\np2 + \n  stat_gradientinterval(\n      aes(xdist = dist_student_t(df = df.residual(m1), mu = .fitted, sigma = .se.fit)), \n  ) + \n  labs(subtitle = \"stat_gradientinterval()\")\n```\n\n### `stat_dots()`\n\nModel Terms:\n\n```{r}\np1 +\n  stat_dots(\n      aes(xdist = dist_student_t(df = df.residual(m1), mu = estimate, sigma = std.error))\n  ) + \n  labs(subtitle = \"stat_dots()\")\n```\n\nMarginal Means:\n\n```{r}\np2 + \n  stat_dots(\n      aes(xdist = dist_student_t(df = df.residual(m1), mu = .fitted, sigma = .se.fit)), \n  ) + \n  labs(subtitle = \"stat_dots()\")\n```\n\nYou can also change the number of dots:\n\nModel Terms:\n\n```{r}\np1 +\n  stat_dots(\n      aes(xdist = dist_student_t(df = df.residual(m1), mu = estimate, sigma = std.error))\n      , quantiles = 50\n  ) + \n  labs(subtitle = \"stat_dots()\")\n```\n\nMarginal Means:\n\n```{r}\np2 + \n  stat_dots(\n      aes(xdist = dist_student_t(df = df.residual(m1), mu = .fitted, sigma = .se.fit)) \n      , quantiles = 50\n  ) + \n  labs(subtitle = \"stat_dots()\")\n```\n\nThere are also three different layouts\n\n`layout = \"bin\"`:\n\n```{r}\np2 + \n  stat_dots(\n      aes(xdist = dist_student_t(df = df.residual(m1), mu = .fitted, sigma = .se.fit)) \n      , quantiles = 50\n      , layout = \"bin\"\n  ) + \n  labs(subtitle = \"stat_dots()\")\n```\n\n`layout = \"weave\"`:\n\n```{r}\np2 + \n  stat_dots(\n      aes(xdist = dist_student_t(df = df.residual(m1), mu = .fitted, sigma = .se.fit)) \n      , quantiles = 50\n      , layout = \"weave\"\n  ) + \n  labs(subtitle = \"stat_dots()\")\n```\n\n`layout = \"swarm\"`:\n\n```{r}\np2 + \n  stat_dots(\n      aes(xdist = dist_student_t(df = df.residual(m1), mu = .fitted, sigma = .se.fit)) \n      , quantiles = 50\n      , layout = \"swarm\"\n  ) + \n  labs(subtitle = \"stat_dots()\")\n```\n\n### `stat_dotsinterval()`\n\nModel Terms:\n\n```{r}\np1 +\n  stat_dotsinterval(\n      aes(xdist = dist_student_t(df = df.residual(m1), mu = estimate, sigma = std.error))\n      , quantiles = 50\n  ) + \n  labs(subtitle = \"stat_dotsinterval()\")\n```\n\nMarginal Means:\n\n```{r}\np2 + \n  stat_dotsinterval(\n      aes(xdist = dist_student_t(df = df.residual(m1), mu = .fitted, sigma = .se.fit)) \n      , quantiles = 50\n  ) + \n  labs(subtitle = \"stat_dotsinterval()\")\n```\n\nYou can apply many of the same arguments as \"regular\" `stat_dots()`\n\nModel Terms:\n\n```{r}\np1 +\n  stat_dotsinterval(\n      aes(xdist = dist_student_t(df = df.residual(m1), mu = estimate, sigma = std.error))\n      , quantiles = 50\n      , layout = \"swarm\"\n  ) + \n  labs(subtitle = \"stat_dotsinterval()\")\n```\n\nMarginal Means:\n\n```{r}\np2 + \n  stat_dotsinterval(\n      aes(xdist = dist_student_t(df = df.residual(m1), mu = .fitted, sigma = .se.fit)) \n      , quantiles = 50\n      , layout = \"swarm\"\n  ) + \n  labs(subtitle = \"stat_dotsinterval()\")\n```\n\n### `stat_halfeye()`+ `stat_dots()`\n\nModel Terms:\n\n```{r}\np1 +\n  stat_dots(\n      aes(xdist = dist_student_t(df = df.residual(m1), mu = estimate, sigma = std.error))\n      , quantiles = 50\n      , side = \"bottomleft\"\n      , layout = \"swarm\"\n  ) + \n  stat_halfeye(\n    aes(xdist = dist_student_t(df = df.residual(m1), mu = estimate, sigma = std.error))\n  ) + \n  labs(subtitle = \"`stat_halfeye()`+ `stat_dots()\")\n```\n\nMarginal Means:\n\n```{r}\np2 + \n  stat_dots(\n      aes(xdist = dist_student_t(df = df.residual(m1), mu = .fitted, sigma = .se.fit)) \n      , quantiles = 50\n      , side = \"bottomleft\"\n      , layout = \"swarm\"\n  ) + \n  stat_halfeye(\n    aes(xdist = dist_student_t(df = df.residual(m1), mu = .fitted, sigma = .se.fit)) \n  ) + \n  labs(subtitle = \"`stat_halfeye()`+ `stat_dots()\")\n```\n\n# Simple Slopes\n\nLet's say we want to know if married and unmarried people differ in their self-rated health as a function of their age:\n\n```{r}\ngsoep_ex2 <- gsoep_ex %>%\n  filter(marital %in% c(\"Married\", \"Never Married\"))\ngsoep_ex2\n\nm2 <- lm(SRhealth ~ age + marital + age:marital, data = gsoep_ex2)\ntidy(m2)\n```\n\nWe can plot this using an extension of `geom_ribbon()`, `stat_lineribbon()`\n\n```{r}\ngsoep_ex2 %>%\n  group_by(marital) %>%\n  data_grid(age= seq_range(age, n = 101)) %>%\n  ungroup() %>%\n  augment(m2, newdata = ., se_fit = T) %>%\n  ggplot(aes(x = age*10, fill = ordered(marital), color = ordered(marital))) +\n    stat_lineribbon(\n      aes(ydist = dist_student_t(df = df.residual(m2), mu = .fitted, sigma = .se.fit)),\n      alpha = 1/4) + \n    scale_fill_brewer(palette = \"Set2\") +\n    scale_color_brewer(palette = \"Dark2\") +\n    labs(x = \"Age (Years)\", y = \"Predicted Self-Rated Health\"\n         , fill = \"Marital Status\", color = \"Marital Status\") + \n    my_theme()\n```\n\n-   I promised I wouldn't go Bayes, but I never promised I wouldn't bootstrap!\\\n-   Knowing how to get bootstrapped confidence and/or prediction intervals is important, especially if you work with any sort of multilevel / hierarchical models\\\n-   Getting bootstrapped interval estimates is easy to get point estimates, but it's a little harder if we want to get it around prediction lines\n    -   (i.e. there's no great built in funcitons in `R` that get it for you, in my opinion)\n\nBut first, let's get some longitudinal data that let's us look at the interaction between marital status and changes in self-rated health within a person as they age:\n\n```{r}\nset.seed(5)\ngsoep_ex3 <- gsoep %>%\n  select(SID, age, marital, gender, SRhealth) %>%\n  filter(marital %in% c(1,4)) %>%\n  group_by(SID) %>%\n  mutate(marital = min(marital, na.rm = T)) %>%\n  ungroup() %>%\n  mutate(marital = factor(\n    marital\n    , c(1,4)\n    , c(\"Married\", \"Never Married\")\n    ), age = age/10\n    , gender = factor(gender, c(1,2), c(\"Male\", \"Female\"))) %>%\n  drop_na()\n\ngsoep_ex3 <- gsoep_ex3 %>%\n  filter(SID %in% sample(unique(gsoep_ex3$SID), 2000))\n```\n\nThe critical term is the interaction between the two:\n\n```{r}\nm3 <- lmer(SRhealth ~ age + marital + age:marital + (age | SID), data = gsoep_ex3)\ntidy(m3)\n```\n\nChanges in health differ across marital groups\n\n-   But how?\n    -   Interactions can often be tricky to unpack by point estimates alone\n    -   So we may want to plot separate trajectories for married and unmarried people\n\n```{r, cache = T}\npredIntlme4 <- function(m, mod_frame, ref){\n  ## get bootstrapped estimates\n  b <- bootMer(\n    m\n    , FUN = function(x) lme4:::predict.merMod(\n      x\n      , newdata = mod_frame\n      , re.form = ref\n      )\n    , nsim = 100 # do not use 100 in practice, please\n    , parallel = \"multicore\"\n    , ncpus = 16\n    )\n  \n  ## get long form bootstrapped draws\n  b_df <- bind_cols(\n    mod_frame\n    , t(b$t) %>%\n    data.frame()\n  ) %>%\n    pivot_longer(\n       cols = c(-age, -marital)\n      , names_to = \"boot\"\n      , values_to = \"pred\"\n    )\n  return(list(boot = b, b_df = b_df))\n}\n\npred_fx_fun <- function(m){\n  mod_frame <- crossing(\n    age = seq(min(m@frame$age), max(m@frame$age), .1)\n    , marital = levels(m@frame$marital)\n  )\n  boot <- predIntlme4(m = m, mod_frame = mod_frame, ref = NA)\n}\n\nboot3 <- pred_fx_fun(m3)\nb_df3 <- boot3$b_df\nb3 <- boot3$boot\n```\n\n## `geom_line()`\n\n```{r}\nb_df3 %>%\n  ggplot(aes(x = age, y = pred)) + \n    geom_line(\n      aes(color = marital, group = interaction(marital, boot))\n      , alpha = .2, size = .25\n      ) + \n    my_theme()\n```\n\n## `geom_lineribbon()`: summarized\n\n```{r}\nb_df3 %>%\n  group_by(marital, age) %>%\n  median_qi(pred) %>%\n  ggplot(aes(x = age, y = pred, ymin = .lower, ymax = .upper)) +\n  geom_lineribbon(aes(fill = marital), size = .9) + \n  scale_fill_brewer(palette = \"Set2\") +\n  my_theme()\n```\n\n## `geom_lineribbon()` bands: summarized\n\n```{r}\nb_df3 %>%\n  group_by(marital, age) %>%\n  median_qi(pred, .width = c(.50, .80, .95)) %>%\n  ggplot(aes(x = age, y = pred, ymin = .lower, ymax = .upper)) +\n  geom_lineribbon(size = .9) + \n  scale_fill_brewer() +\n  facet_grid(~marital) + \n  my_theme()\n```\n\n## `stat_lineribbon()` bands: samples\n\n```{r}\nb_df3 %>%\n  ggplot(aes(x = age, y = pred, fill = marital)) + \n  stat_lineribbon(alpha = .25) + \n  my_theme()\n```\n\nWe can also use a new `aesthetic`: `fill_ramp`:\n\n```{r}\nb_df3 %>%\n  ggplot(aes(x = age, y = pred, fill = marital)) + \n  stat_lineribbon(aes(fill_ramp = stat(level))) +\n  my_theme()\n```\n\n## `geom_lineribbon()` gradient: samples\n\n```{r}\nb_df3 %>%\n  ggplot(aes(x = age, y = pred, fill = marital)) + \n  stat_lineribbon(alpha = .25, .width = ppoints(25)) + \n  scale_fill_brewer(palette = \"Set2\") +\n  my_theme()\n```\n\nLet's clean it up:\n\n```{r}\nms <- b_df3 %>% filter(age == max(age)) %>% group_by(marital) %>% summarize(m = mean(pred))\n\nb_df3 %>%\n  ggplot(aes(x = age*10, y = pred, fill = marital, fill_ramp = stat(.width))) + \n  stat_lineribbon(alpha = .25, .width = ppoints(25)) +\n  scale_x_continuous(limits = c(15,100), breaks = seq(15,90,15)) + \n  scale_fill_manual(values = c(\"grey\", \"darkorange\")) + \n  annotate(\"text\", label = \"Married\", x = max(b_df3$age)*10+1, y = ms$m[1], hjust = 0) + \n  annotate(\"text\", label = \"Never\\nMarried\", x = max(b_df3$age)*10+1, y = ms$m[2], hjust = 0) + \n  labs(\n    x = \"Age (Years)\"\n    , y = \"Predicted Self Rated Health\\n(Bootstrapped Interval Estimates)\"\n    , fill = NULL\n    , title = \"Self-Rated Health Declines More Rapidly for Unmarried People\"\n    ) + \n  guides(fill = \"none\") + \n  my_theme()\n```\n\n# Animated Uncertainty\n\n## Ensemble Displays\n\n-   Ensemble displays are an alternative to putting hard boundaries around an interval estimate\n-   Remember that hard boundaries make people interpret categorical differences even when the underlying distribution is continuous\n-   We've already seen this:\n\n```{r, echo = F}\nb_df3 %>%\n  ggplot(aes(x = age, y = pred)) + \n    geom_line(\n      aes(color = marital, group = interaction(marital, boot))\n      , alpha = .2, size = .5\n      ) + \n    my_theme()\n```\n\n-   But the challenge with visualizing uncertainty is between inference and understanding\n-   We need to leverage a knowledge of perception and cognitive processes to help us leverage strengths and overcome weaknesses\n-   Animating visualizations can help us nudge people to process was they see and update their uncertainty estimates over time\n\nHere's a quick example:\n\n```{r, echo = F}\nb_df3 %>%\n  group_by(marital, age) %>%\n  median_qi(pred) %>%\n  ggplot(aes(x = age, y = pred)) +\n    geom_ribbon(\n      aes(fill = marital, ymin = .lower, ymax = .upper)\n      , size = .9, alpha = .5\n      ) + \n    scale_fill_brewer(palette = \"Set2\") +\n    geom_line(\n      data = b_df3\n      , aes(group = interaction(marital, boot))\n      , size = 1\n      ) +\n    facet_grid(~marital) + \n    my_theme() + \n    theme(legend.position = \"none\") + \n    transition_states(boot, 1, 1)\n```\n\nLet's break this down:\n\n```{r}\nb_df3 %>%\n  group_by(marital, age) %>%\n  median_qi(pred) \n```\n\nNow, let's plot the ribbon:\n\n```{r}\nb_df3 %>%\n  group_by(marital, age) %>%\n  median_qi(pred) %>%\n  ggplot(aes(x = age, y = pred)) +\n    geom_ribbon(\n      aes(fill = marital, ymin = .lower, ymax = .upper)\n      , size = .9, alpha = .5\n      ) + \n    scale_fill_brewer(palette = \"Set2\") +\n    facet_grid(~marital) + \n    my_theme() + \n    theme(legend.position = \"none\")\n```\n\nAnd add the lines (all of them, it will be ugly):\n\n```{r}\nb_df3 %>%\n  group_by(marital, age) %>%\n  median_qi(pred) %>%\n  ggplot(aes(x = age, y = pred)) +\n    geom_ribbon(\n      aes(fill = marital, ymin = .lower, ymax = .upper)\n      , size = .9, alpha = .5\n      ) + \n    scale_fill_brewer(palette = \"Set2\") +\n    geom_line(\n      data = b_df3\n      , aes(group = interaction(marital, boot))\n      , size = 1\n      ) +\n    facet_grid(~marital) + \n    my_theme() + \n    theme(legend.position = \"none\")\n```\n\nAnd finally, use `transition_states()` to animate it\n\n```{r, eval = F}\nb_df3 %>%\n  group_by(marital, age) %>%\n  median_qi(pred) %>%\n  ggplot(aes(x = age, y = pred)) +\n    geom_ribbon(\n      aes(fill = marital, ymin = .lower, ymax = .upper)\n      , size = .9, alpha = .5\n      ) + \n    scale_fill_brewer(palette = \"Set2\") +\n    geom_line(\n      data = b_df3\n      , aes(group = interaction(marital, boot))\n      , size = 1\n      ) +\n    facet_grid(~marital) + \n    my_theme() + \n    theme(legend.position = \"none\") + \n    transition_states(boot, 1, 1)\n```\n\n## Hypothetical Outcome Plots (HOPs)\n\n-   Similarly, hypothetical outcome plots let us see plausible mean estimates among raw data\n-   Here's self-rated health (1-5) across married and unmarried individuals:\n\n```{r}\ngsoep_ex3 %>%\n  ggplot(aes(y = marital, x = SRhealth)) + \n    geom_jitter(aes(color = marital), alpha = .5) + \n    my_theme()\n```\n\n-   Using the `ungeviz` package, we can then use the `geom_vpline()` function to sample from the data across groups and plot the mean from different samples:\n\n```{r}\ngsoep_ex3 %>%\n  ggplot(aes(y = marital, x = SRhealth)) + \n    geom_jitter(aes(color = marital), alpha = .25) + \n    geom_vpline(\n      data = sampler(25, group = marital)\n      , height = 0.6\n      , color = \"#D55E00\"\n      ) +\n    scale_color_manual(values = c(\"seagreen2\", \"darkorange\")) + \n    my_theme()\n```\n\nAnd finally, we can animate those samples the `transition_states()` function from the `gganimate` package again:\n\n```{r}\ngsoep_ex3 %>%\n  ggplot(aes(y = marital, x = SRhealth)) + \n    geom_jitter(aes(color = marital), alpha = .5) + \n    geom_vpline(\n      data = sampler(25, group = marital)\n      , height = 0.6\n      , color = \"#D55E00\"\n      ) +\n    scale_color_manual(values = c(\"seagreen2\", \"darkorange\")) + \n    my_theme() + \n    transition_states(.draw, 1, 3)\n```\n\n<!-- * Proportions / Probability   -->\n\n<!--   + icon array -->\n\n<!-- * Point Estimates -->\n\n<!--   + half-eye -->\n\n<!--   + gradient interval -->\n\n<!--   + quantile dotplot -->\n\n<!--   + raincloud -->\n\n<!-- * Animated (sometimes) -->\n\n<!--   + hypothetical outcome plots -->\n\n<!--   + ensemble display -->\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"paged","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"show","code-overflow":"scroll","code-link":true,"code-line-numbers":true,"code-tools":true,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"highlight-style":"tango","self-contained":true,"output-file":"06-week6-workbook.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.269","editor":"visual","theme":["cosmo","custom-styles.scss"],"title":"Week 6 (Workbook) - Visualizing Uncertainty","author":"Emorie D Beck","editor_options":{"chunk_output_type":"console"},"code-copy":true,"toc-float":true,"footer":"PSC 290 - Data Visualization","logo":"https://github.com/emoriebeck/psc290-data-viz-2022/raw/main/01-week1-intro/02-code/02-images/ucdavis_logo_blue.png"},"extensions":{"book":{"multiFile":true}}}}}